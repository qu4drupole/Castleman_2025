---
title: "cell_type_GSEA"
author: "David Smith"
date: "6/01/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(dplyr)
library(purrr)
library(parallel)
library(DESeq2)
# library(Matrix.utils)
library(tidyverse)
library(reshape2)
library(sva)
library(S4Vectors)
library(tibble)
library(apeglm)
library(limma)
library(edgeR)
library(Matrix)
library(Seurat)
library(SeuratDisk)
library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)
library(VennDiagram)
library(gprofiler2)
library(cowplot)
library(pheatmap)
library(here)
library(stringr)
# here::i_am("code/05-GSEA/cell_type_gsea_CD.Rmd")
library(future)
plan(multisession, workers = 4)
options(future.globals.maxSize= 20000*1024^2)
```


Load the data
```{r}

# seu <- readRDS("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/processed/02-annotation/symphony_transfer_integrated_DGS_edited.RDS")

seu <- readRDS("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/processed/02-annotation/symphony_transfer_integrated_DGS_edited_CD-R.RDS")

```


## Subsetting
Only looking at MCD, HVCD and R 

```{r}
Idents(seu) <- 'disease'
# dat_test <- subset(seu, idents = c("R", "MCD", "HVCD"))
dat_test <- seu

# Relabeling plasma cells
DimPlot(dat_test, group.by = "seurat_clusters", label = T, label.size = 3, repel = T, label.box = T)

dat_test$pred_anno_2 <- dat_test$pred_anno
dat_test$pred_anno_2[dat_test$seurat_clusters %in% c(16,17,6)] <- "Plasma cells"
dat_test$pred_anno_2[dat_test$pred_anno_2 == "Proliferating plasma cells"] <- "Plasma cells"

```


Rerunning combat normalization

code coming from cropSeq-preprocessing_aggregated.Rmd

When I use the raw RNA counts the data get pretty squished, which could be fine, but aesthetically, it's strange to see top expression values around 2.
One interesting observation on the SCT adjusted counts, is the baseline nCount_SCT across GEMs is very different. I wonder whether I should try using SCT counts as input for ComBat?

```{r}
# going backward from KFD,R selected data (dat_test) loaded from memory
# VlnPlot(dat_test, features=c('nCount_SCT'))
# dat_test <- subset(dat_test, subset = nCount_SCT > 1500)
dat_list <- SplitObject(dat_test, split.by = "edit.ident")

drop_genes <- c()
for(i in 1:length(dat_list)){
  DefaultAssay(dat_list[[i]]) <- "RNA"
  gen_mat <- GetAssayData(dat_list[[i]])
  zero.genes <- rownames(dat_test)[apply(gen_mat, 1, function(x) all(x==0))]
  drop_genes <- union(drop_genes, zero.genes)
  # dat_list[[i]] <- NormalizeData(dat_list[[i]])
}

#############
# METHOD: min GEM median
# # getting the raw data,
# raw.counts <- lapply(dat_list, GetAssayData, "counts")
# 
# med.value <- lapply(raw.counts, function(x) median(colSums(x)))
# # med.value <- lapply(raw.counts, function(x) quantile(colSums(x),0.75))
# min_median <- median(unlist(med.value))

# norm.counts <- lapply(raw.counts,
#                         function(x) apply(x, 2,
#                                           function(c) c*(min_median/sum(c))))
# dat_list <- lapply(dat_list, NormalizeData, scale.factor=min_median)
# norm.matrix <- log1p(norm.matrix)

#############
# METHOD: RNA seurat normalize
# dat_list <- lapply(dat_list, NormalizeData)
# norm.counts <- lapply(dat_list, GetAssayData, "data")
# norm.matrix <- Reduce(cbind, norm.counts)
DefaultAssay(dat_test) <- "RNA"
# dat_test <- NormalizeData(dat_test)
norm.matrix <- GetAssayData(dat_test, slot = "data")

#############
# METHOD: SCT seurat normalize
# DefaultAssay(dat_test) <- "SCT"
# norm.matrix <- GetAssayData(dat_test, slot = "data")

# running combat
norm.matrix <- norm.matrix[!(rownames(norm.matrix)%in%drop_genes),]
# batch <- dat_test$seq_chem
batch <- dat_test$edit.ident
corrected.matrix <- ComBat(norm.matrix, batch = batch, mean.only = T, BPPARAM = MulticoreParam(4))

## Filter out negative or zero genes/trash?
# gene.zeros <- apply(corrected.matrix, 1, function(g) sum(g) < 10)
# corrected.matrix.filter <- corrected.matrix[!gene.zeros,]
# # bump to zero by gene? or sample? gene
# corrected.matrix.filter <- apply(corrected.matrix.filter, 1, function(g) g+min(g))

# corrected.assay <- CreateAssayObject(data=corrected.matrix.filter)
corrected.assay <- CreateAssayObject(data=corrected.matrix)
dat_test[['combat']] <- corrected.assay
DefaultAssay(dat_test) <- "combat"


```


## Visualizing the data

From the codex data, we observed obvious cell abundance and spatial orientation differences between the cases.
How much of that difference is apparent in the seq data?
```{r}
gex_list <- list()
for(s in seq_along(dat_list)){
  DefaultAssay(dat_list[[s]]) <- "RNA"
  gex_list[[s]] <- DietSeurat(dat_list[[s]], assays="RNA")
  gex_list[[s]] <- SCTransform(gex_list[[s]], vst.flavor = "v2") %>% RunPCA(npcs = 30, verbose = FALSE)
}

features <- SelectIntegrationFeatures(object.list = gex_list, nfeatures = 2000)
gex_list <- PrepSCTIntegration(object.list = gex_list, anchor.features = features)
gex.anchors <- FindIntegrationAnchors(object.list = gex_list, normalization.method = "SCT",
                                         anchor.features = features, reduction = 'rpca')
gex.combined.sct <- IntegrateData(anchorset = gex.anchors, normalization.method = "SCT")

gex.combined.sct <- RunPCA(gex.combined.sct, verbose = FALSE)
gex.combined.sct <- RunUMAP(gex.combined.sct, reduction = "pca", dims = 1:30, verbose = FALSE)
gex.combined.sct <- RunTSNE(gex.combined.sct, dims = 1:30)

saveRDS(gex.combined.sct, "../../processed/02-annotation/symphony_transfer_integrated_DGS_edited_CD-R.RDS")

pdf(
  file = "outs/CD/UMAPS",
  height = 8,
  width = 11
)

DimPlot(gex.combined.sct, group.by = "pred_anno", label = T, label.box = T, repel = T) + theme(legend.position = "none")
DimPlot(gex.combined.sct, group.by = "edit.ident") 
DimPlot(gex.combined.sct, group.by = "chem") 

dev.off()

```

Looking at cell representation by replicate
```{r}
# cell_comp <- lapply(unique(dat_test$comp.ident), function(r) table(dat_test$Man_anno[dat_test$comp.ident==r],))
# names(cell_comp) <- unique(dat_test$comp.ident)

cell_comp <- dat_test@meta.data %>% dplyr::group_by(edit.ident, pred_anno) %>%
  dplyr::summarise("cell_count"=length(pred_anno))

cell_comp_sums <-table(dat_test$edit.ident)
# cell_comp_sums <-table(dat_test$pred_anno_2)

# cell_comp$rel_count <- apply(cell_comp, 1, function(x) as.numeric(x[3]) / cell_comp_sums[x[2]])
cell_comp$rel_count <- apply(cell_comp, 1, function(x) as.numeric(x[3]) / cell_comp_sums[x[1]])

ggplot(cell_comp, aes(fill=edit.ident, y=rel_count, x=pred_anno)) + 
    geom_bar(position="stack", stat="identity") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, 
                                     vjust = 0.5,
                                     hjust=1,
                                     ))

cell_comp <- dat_test@meta.data %>% dplyr::group_by(disease, pred_anno_2) %>%
  dplyr::summarise("cell_count"=length(pred_anno_2))

# cell_comp_sums <-table(dat_test$disease)
cell_comp_sums <-table(dat_test$pred_anno_2)

cell_comp$rel_count <- apply(cell_comp, 1, function(x) as.numeric(x[3]) / cell_comp_sums[x[2]])

ggplot(cell_comp, aes(fill=disease, y=rel_count, x=pred_anno_2)) + 
    geom_bar(position="stack", stat="identity") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, 
                                     vjust = 0.5,
                                     hjust=1,
                                     ))
```




For the DEG test with integrated assay. Didn't rerun cell type marker search
```{r}
Idents(dat_test) <- "pred_anno_2"
# make selection of test genes
drop_genes <- grep("^MT-", rownames(dat_test), value = T)
drop_genes <- c(drop_genes, grep("^RP[LS]|^MRPL|IGH|HLA", rownames(dat_test), value = T))
test_features <- rownames(dat_test)[!(rownames(dat_test) %in% drop_genes)]
# ct_markers <- FindAllMarkers(dat_test, assay='SCT', test.use = 'MAST')
# ct_markers <- FindAllMarkers(dat_test, features = test_features)
# 
# # should I specify just positive?
# ct_markers_pos <- ct_markers[ct_markers$avg_log2FC>0,]

```


Now running the R vs. KFD differential expression, but restrict genes to the cell-specific markers.
```{r}
# KFD_deg <- mclapply(unique(Idents(dat_test)), function(x) FindMarkers(object=dat_test,
#                                                                       slot='data',
#                                                                       test.use = 'MAST',
#                                                                       ident.1 = "KFD",
#                                                                       ident.2 = "R",
#                                                                       group.by = "disease",
#                                                                       subset.ident = x),
#                     mc.cores = 2)

# only test cell types with at 50 cells from each cell type
good_ct.mcd <- table(Idents(dat_test)[dat_test$disease=="MCD"])
good_ct.mcd <- names(good_ct.mcd)[good_ct.mcd>50]
good_ct.hvcd <- table(Idents(dat_test)[dat_test$disease=="HVCD"])
good_ct.hvcd <- names(good_ct.hvcd)[good_ct.hvcd>50]
good_ct.r <- table(Idents(dat_test)[dat_test$disease=="R"])
good_ct.r <- names(good_ct.r)[good_ct.r>50]
good_ct <- intersect(good_ct.hvcd, good_ct.mcd)
good_ct <- intersect(good_ct, good_ct.r)

# We also want to include 

## MCD grade DEG
Idents(dat_test) <- "pred_anno_2"
# mcd_dat <- subset(dat_test, idents=c("R","MCD"))
# Idents(mcd_dat) <- "pred_anno"
mcd_deg <- lapply(good_ct, function(x) {
  FindMarkers(object=dat_test,
              assay = "combat",
              min.pct = 0.1,                     # only for combat testing...
              features = test_features,
              group.by = "disease",
              ident.1 = "MCD",
              ident.2 = "R",
              subset.ident = x)
  })
names(mcd_deg) <- good_ct

# We also need to lymphatics, and endothelial for MCD
# mcd_deg[['Lymphatics']] <- FindMarkers(object=dat_test,
#                                        assay = "combat",
#                                        min.pct = 0.1,                     # only for combat testing...
#                                        features = test_features,
#                                        group.by = "disease",
#                                        ident.1 = "MCD",
#                                        ident.2 = "R",
#                                        subset.ident = 'Lymphatics')
# 
# mcd_deg[['Endothelial cells']] <- FindMarkers(object=dat_test,
#                                        assay = "combat",
#                                        min.pct = 0.1,                     # only for combat testing...
#                                        features = test_features,
#                                        group.by = "disease",
#                                        ident.1 = "MCD",
#                                        ident.2 = "R",
#                                        subset.ident = 'Endothelial cells')
## HVCD grade DEG
hvcd_deg <- lapply(good_ct, function(x) {
  FindMarkers(object=dat_test,
              assay = "combat",
              min.pct = 0.1,                     # only for combat testing...
              features = test_features,
              group.by = "disease",
              ident.1 = "HVCD",
              ident.2 = "R",
              subset.ident = x)
  })

names(hvcd_deg) <- good_ct
# defining the filtered DEGs, as genes unique to cell type (as opposed to using cell type markers)

# MCD
deg_list <- unlist(lapply(mcd_deg, function(x) rownames(x)[x$p_val_adj < 0.05])) #changed
deg_background <- table(deg_list)
quantile(deg_background, c(0.2,0.5,0.97,0.98,0.99,1))
deg_background <- names(deg_background)[deg_background > quantile(deg_background,0.3)] #changed

mcd_deg_unique <- lapply(mcd_deg, function(x) x[!(rownames(x) %in% deg_background),])

# HVCD
deg_list <- unlist(lapply(hvcd_deg, function(x) rownames(x)[x$p_val_adj < 0.1])) #changed
deg_background <- table(deg_list)
quantile(deg_background, c(0.2,0.5,0.97,0.98,0.99,1))
deg_background <- names(deg_background)[deg_background > quantile(deg_background,0.3)] #changed

hvcd_deg_unique <- lapply(hvcd_deg, function(x) x[!(rownames(x) %in% deg_background),])

```

```{r}
# saveRDS(mcd_deg_unique, "outs/CD/mcd_combat_deg_unique.RDS")
# saveRDS(hvcd_deg_unique, "outs/CD/hvcd_combat_deg_unique.RDS")
mcd_deg_unique <- readRDS("outs/CD/mcd_deg_unique.RDS")
hvcd_deg_unique <- readRDS("outs/CD/hvcd_deg_unique.RDS")
```


# Exporting for IREA

```{r}
for(i in seq_along(mcd_deg_unique)){
  res <- mcd_deg_unique[[i]]
  rownames(res) <- str_to_title(rownames(res))
  write.csv(res, paste0("outs/CD/MCD/DEG/",names(mcd_deg_unique)[i],"_DEG_results.csv"))
}

for(i in seq_along(hvcd_deg_unique)){
  res <- hvcd_deg_unique[[i]]
  rownames(res) <- str_to_title(rownames(res))
  write.csv(res, paste0("outs/CD/HVCD/DEG/",names(hvcd_deg_unique)[i],"_DEG_results.csv"))
}

```




Writing the within cell type differential expression results to file
```{r}
# lapply(names(KFD_deg_filtered), function(x) write.csv(KFD_deg_filtered[x],paste0("outs/KFD/cell_type_DEG_markerFiltered/",x,".csv")))
lapply(names(hvcd_deg_unique), function(x) write.csv(KFD_deg_unique[x], paste0("outs/HVCD/cell_type_DEG_RNA/",x,".csv")))
lapply(names(mcd_deg_unique), function(x) write.csv(KFD_deg_unique[x], paste0("outs/MCD/cell_type_DEG_RNA/",x,".csv")))
```

Which cells have the most differences between R and KFD.
The major discrepency 
```{r}
ct_markers %>% dplyr::group_by(cluster) %>% dplyr::summarise(sum(p_val_adj < 0.05))

sample(rownames(ct_markers[(ct_markers$p_val_adj < 0.05) & ct_markers$cluster=="Naive B cells",]), 5)

ct_markers[c("ARL4C.1", "TSPAN14.1", "GIMAP8"),]


```


Making the Venn diagram
```{r}
deg_ct_genes <- lapply(KFD_deg, rownames)
venn.diagram(deg_ct_genes[1:5], "outs/KFD/cell_type_DEG/venn_celltype.jpeg")

deg_ct_genes <- lapply(KFD_deg_filtered, rownames)
venn.diagram(deg_ct_genes[1:5], "outs/KFD/cell_type_DEG_markerFiltered/venn_celltype.jpeg")

# so the DEGs actually are unique to cell type
length(Reduce(union, deg_ct_genes))
```
Running the enrichment analysis
```{r}
# plotting function
make_dot_plot <- function(res){
  pdata <- res$result
  if(nrow(pdata) < 15){
    return(NULL)
  }
  pdata <- pdata[!duplicated(pdata$term_name),]
  pdata$f1_score <- (pdata$precision*pdata$recall)/(pdata$precision + pdata$recall)
  pdata$f2_score <- 5*(pdata$precision*pdata$recall)/(4*pdata$precision + pdata$recall)
  pdata <- pdata[order(pdata$p_value, decreasing = F),]
  pdata <- pdata[1:15,]
  pdata$term_name <- factor(pdata$term_name, levels = pdata$term_name[order(pdata$f2_score)], ordered = T)
  pdata$recall_size <- factor(cut(pdata$recall, breaks = 3))
  p <- ggplot(pdata, aes(x=f2_score, y=term_name)) +
    geom_point(aes(colour=-log(p_value), size=recall_size)) +
    scale_colour_viridis_c(option='D', direction = 1) +
    theme_minimal()
  return(p)
}

# ct <- 'Activated and memory B cells'

for(ct in names(mcd_deg)){
  print(ct)
  deg_res <- mcd_deg[[ct]]
  # deg_res <- hvcd_deg[[ct]]
  # deg_res <- mcd_deg_unique[[ct]]
  # deg_res <- hvcd_deg_unique[[ct]]
  if(nrow(deg_res) < 15){
    next
  }
  # up regulated
  sig.up <- row.names(deg_res)[(deg_res$p_val_adj < 0.1) & (deg_res$avg_log2FC > 0)] # adjust p-value as seen fit
  p1 <- p3 <- NULL
  if(length(sig.up) > 5){
    gostres <- gost(sig.up,
                    user_threshold = 0.2,
                    # significant = FALSE,
                    correction_method = 'fdr',
                    domain_scope = "custom_annotated",
                    # sources = c('GO', 'KEGG', 'REAC', 'TF', 'HP', 'WP'),
                    sources = c('REAC'),
                    custom_bg = rownames(dat_test)
                    )
    if(!is.null(gostres)){
      p <- make_dot_plot(gostres)
    }

    if(!is.null(p)){
      p1 <- p + ggtitle(paste0(ct, ", up-regulated"))
    }
  }
  # down regulated
  sig.dn <- row.names(deg_res)[(deg_res$p_val_adj < 0.1) & (deg_res$avg_log2FC < 0)] # adjust p-value as seen fit
  p2 <- p4 <- NULL
  if(length(sig.dn) > 5){
    gostres <- gost(sig.dn,
                    user_threshold = 0.2,
                    # significant = FALSE,
                    correction_method = 'fdr',
                    domain_scope = "custom_annotated",
                    # sources = c('GO', 'KEGG', 'REAC', 'TF', 'HP', 'WP'),
                    sources = c('REAC'),
                    custom_bg = rownames(dat_test)
                    )
    if(!is.null(gostres)){
      p <- make_dot_plot(gostres)
    }
    if(!is.null(p)){
      p2 <- p + ggtitle(paste0(ct, ", down-regulated"))
    }
  }
  pdf(paste0("outs/CD/MCD/enrichment_results_combat/",ct,"reactome_enrichments.pdf"), width = 10, height = 6)
  if(!any(sapply(list(p1,p2), is.null))){
    print(p1)
    print(p2)
  } else if(is.null(p1)){
    print(p2)
  } else if(is.null(p2)){
    print(p1)
  }
  
  while (!is.null(dev.list()))  dev.off()
}


```

### comparing enrichment results between HVCD and MCD
```{r}
fbeta <- function(precision, recall, b){
  s <- ((1+b)*precision*recall)/(b*precision + recall)
  return(s)
}
```


```{r}
ct <- "Activated and memory B cells"
# ct <- "Follicular dendritic cells"
for(ct in names(mcd_deg_unique)){
  deg_res <- mcd_deg_unique[[ct]]
  sig.up <- row.names(deg_res)[(deg_res$p_val_adj < 0.05) & (deg_res$avg_log2FC > 0)] # adjust p-value as seen fit
  gostres <- gost(sig.up,
                      user_threshold = 0.2,
                      correction_method = 'fdr',
                      domain_scope = "custom_annotated",
                      sources = c('GO', 'KEGG', 'REAC', 'TF', 'HP', 'WP'),
                      # sources = c('REAC'),
                      # custom_bg = rownames(deg_res),
                  custom_bg = rownames(dat_test),
                  evcodes = T
                      )
  gostres_mcd <- gostres$result
  gostres_mcd$f_score <- gostres_mcd %>% dplyr::select(precision, recall) %>% pmap(fbeta, b=0.2) %>% unlist
  
  deg_res <- hvcd_deg_unique[[ct]]
  sig.up <- row.names(deg_res)[(deg_res$p_val_adj < 0.05) & (deg_res$avg_log2FC > 0)] # adjust p-value as seen fit
  gostres <- gost(sig.up,
                      user_threshold = 0.1,
                      correction_method = 'fdr',
                      domain_scope = "custom_annotated",
                      sources = c('GO', 'KEGG', 'REAC', 'TF', 'HP', 'WP'),
                      # sources = c('REAC'),
                      # custom_bg = rownames(deg_res),
                  custom_bg = rownames(dat_test),
                  evcodes = T
                      )
  gostres_hvcd <- gostres$result
  gostres_hvcd$f_score <- gostres_hvcd %>% dplyr::select(precision, recall) %>% pmap(fbeta, b=0.2) %>% unlist
  
  ###
  # exploring comparisons...can we filter out redundant GO terms?
  #   -maybe by parent terms?
  
  shared_names <- intersect(gostres_hvcd$term_name, gostres_mcd$term_name)
  
  ###
  # filtering on enrichment differences
  
  gos_hvcd_filter <- gostres_hvcd[gostres_hvcd$term_name %in% shared_names,]
  gos_mcd_filter <- gostres_mcd[gostres_mcd$term_name %in% shared_names,]
  
  
  # hdata <- merge(gos_hvcd_filter, gos_mcd_filter, by="term_name") %>% filter(!duplicated(term_name))
  hdata <- merge(gostres_hvcd, gostres_mcd, by="term_name", all=T, suffixes = c(".UCD",".MCD")) %>% filter(!duplicated(term_name))
  rownames(hdata) <- hdata$term_name
  hdata <- hdata %>% dplyr::select(p_value.UCD, p_value.MCD, f_score.UCD, f_score.MCD, intersection.UCD, intersection.MCD)
  hdata$f_score.UCD <- -1*hdata$f_score.UCD
  hdata$f_score.UCD[is.na(hdata$f_score.UCD)] <- 0; hdata$f_score.MCD[is.na(hdata$f_score.MCD)] <- 0
  hdata$diff <- hdata$f_score.UCD + hdata$f_score.MCD
  # hdata$p_value.x <- log(hdata$p_value.x)*-1; hdata$p_value.y <- log(hdata$p_value.y)*-1
  keep <- abs(hdata$diff) > quantile(abs(hdata$diff), 0.5)
  hdata_ <- hdata[keep,]
  keep <- apply(hdata_[,c("p_value.UCD", "p_value.MCD")], 1, function(x) any(x < 0.1, na.rm = T))
  hdata_ <- hdata_[keep,]

  write.csv(hdata_, paste0("outs/CD/ct_enrichment_comparison/",ct,"_aggRes.csv"))
}

```

--Key terms--
Follicular dendritic cells: 
__common__
'Schwann cell development', 'positive regulation of lipid storage', 'platelet-derived growth factor receptor binding', 'vascular endothelial growth factor production', 'positive regulation of T-helper 1 type immune response', 'axonogenesis', 'triglyceride biosynthetic process', 'metalloendopeptidase activity', 'angiogenesis', 'collagen-containing extracellular matrix', 'blood vessel morphogenesis', 'Extracellular matrix organization', 'epithelial cell development', 'anchoring junction'
__unique__
'interleukin-1 beta production'

Macrophage: 
__common__
'Efferocytosis', 'response to biotic stimulus', 'Factor: EGR1; motif: NNMCGCCCACGCNN; match class: 1', 'inflammatory response', 'defense response', 'Inflammatory mediator regulation of TRP channels', 'Longevity regulating pathway', 'negative regulation of leukocyte apoptotic process', 'negative regulation of locomotion', 'Apelin signaling pathway', 'VEGFA-VEGFR2 Pathway'
__unique__
...

Fibroblasts: 
__common__
'ERK1 and ERK2 cascade', 'chondrocyte differentiation', 'positive regulation of endothelial cell proliferation', 'Hippo signaling pathway','regulation of chemotaxis','myeloid cell differentiation','MAPK cascade','secretory vesicle','Factor: pax-6; motif: NYACGCWTSANYGMNCN','Factor: AP-2gamma; motif: GCCYNCRGSN',"cell migration involved in sprouting angiogenesis","Abnormal vascular morphology"
__unique__
...

Stromal cells: 
__common__
'Factor: E2F; motif: GGCGSG; match class: 1','Complement and coagulation cascades','Oxidative stress response','transcription factor AP-1 complex','cellular response to stimulus','endomembrane system','response to stress','cell migration','VEGFA VEGFR2 signaling','hemopoiesis','regulation of cell adhesion','Factor: Egr-1; motif: GCGCATGCG'
__unique__
...

Activated and memory B cells: 
__common__
'Necroptosis','protein kinase regulator activity'
__unique__
'interleukin-27 receptor activity','interleukin-6 receptor activity','oncostatin-M receptor activity','interleukin-11 receptor activity','palmitoleoyltransferase activity','Chronic decreased circulating IgG1','Chronic decreased circulating IgG4','Elevated hepatic iron concentration'

T Follicular Helper cells: 
__common__

__unique__
...

Making the plots

Using pathways Vinodh identified

```{r}
# key_terms <- c('Schwann cell development', 'positive regulation of lipid storage', 'platelet-derived growth factor receptor binding', 'vascular endothelial growth factor production', 'positive regulation of T-helper 1 type immune response', 'axonogenesis', 'triglyceride biosynthetic process', 'metalloendopeptidase activity', 'angiogenesis', 'collagen-containing extracellular matrix', 'blood vessel morphogenesis', 'Extracellular matrix organization', 'epithelial cell development', 'anchoring junction','interleukin-1 beta production')

# hdata_ <- hdata_[key_terms,]

# Using pathways Vinodh identified
#   fibroblasts, stromal cells, FDC, plasma cells, macrophages and memory/effector T cells
#   Fibroblasts, Stromal cells, Follicular dendritic cells, Plasma cells, Macrophages, Memory or effector T cells
ctoi <- c("Fibroblasts", "Stromal cells", "Follicular dendritic cells", 
          "Plasma cells", "Macrophages", "Memory or effector T cells")

plts <- list()
for(ct in ctoi){
  hdata_ <- read.csv(paste0("../../figures/rnaseq_enrich/ct_enrichments/",ct,"_aggRes.csv"), row.names = 1)
  hdata_ <- hdata_[hdata_$select.term == "y",]
  pdata <- data.frame(p_value = c(hdata_$p_value.UCD, hdata_$p_value.MCD), 
                      f_score = c(hdata_$f_score.UCD, hdata_$f_score.MCD),
                      term = rep(rownames(hdata_),2),
                      disease = c(rep("hvcd", nrow(hdata_)), rep("mcd", nrow(hdata_))))
  pdata$term <- factor(pdata$term, levels = rownames(hdata_)[order(hdata_$diff)])
  pdata$logp <- -1*log(pdata$p_value)
  pdata$logp[pdata$logp>16] <- 16
  pdata$logp[is.na(pdata$logp)] <- 0
  plts[[ct]] <- ggplot(pdata, aes(x=f_score, y=term, fill=logp))+
    geom_bar(position="dodge2", stat="identity")+
    scale_fill_viridis_c(option='D', direction = 1, end = max(pdata$logp)/16) +
    theme_minimal()+
    ggtitle(ct)+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
          axis.text.y = element_text(size=5))
}

plot_grid(plts, col=3)

```



## Trying pathfindR on each ct DEG results
I can't install pathfindR, so just going to prepare the input:
dataframe of: gene symbol, logFC, p.value

```{r}
# also drop common DEGs from test genes
mcd_deg <- lapply(good_ct, function(x) {
  FindMarkers(object=dat_test,
              assay = "combat",
              features = test_features,
              group.by = "disease",
              ident.1 = "MCD",
              ident.2 = "R",
              subset.ident = x)
  })
names(mcd_deg) <- good_ct
for(ct in good_ct){
  # deg_res <- KFD_deg_pathfindr[[ct]]
  deg_res <- KFD_deg_unique[[ct]]
  out <- data.frame(list(symbol = row.names(deg_res),
                         logFC = deg_res$avg_log2FC,
                         pval = deg_res$p_val_adj))
  write.csv(out, paste0("outs/KFD/enrichment_results/pathfindR/input/",ct,".csv"), row.names = FALSE)
}

```

exporting
```{r}
saveRDS(dat_test, "../../processed/02-annotation/symphony_transfer_integrated_DGS_edited_CD-R.RDS")
```




```{r}
ct_seu_diffex <- function(seu, ct, disease='KFD'){
  print(ct)
  DefaultAssay(seu) <- "combatBatch" #already set
  Idents(seu) <- "Man_anno"
  markers <- FindMarkers(seu, test.use = 'wilcox',
                       ident.1 = disease, ident.2 = "R", group.by = 'disease', subset.ident = ct,
                       min.pct = 0.4, logfc.threshold = 0)
  resLFC <- markers[order(markers$avg_log2FC, decreasing = T),]
  geneList <- resLFC$avg_log2FC; names(geneList) <- rownames(resLFC)
  # convert gene symbols to entrez
  newIDs <- mapIds(org.Hs.eg.db, keys = rownames(resLFC),
         column = "ENTREZID", keytype = "SYMBOL")
  entrz.geneList <- geneList
  names(entrz.geneList) <- newIDs
  entrz.geneList <- entrz.geneList[!(is.na(names(entrz.geneList)))]
  kegg.res <- gseKEGG(geneList     = entrz.geneList,
               organism     = 'hsa',
               minGSSize    = 20,
               pvalueCutoff = 0.5,
               verbose      = FALSE)
  go.res <- gseGO(geneList     = entrz.geneList,
                OrgDb        = org.Hs.eg.db,
                ont          = "BP",
                minGSSize    = 50,
                maxGSSize    = 500,
                pvalueCutoff = 0.5,
                verbose      = FALSE)
  # visualize
  pdf(paste0("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/outs/",disease,"_",ct,"_enrichment.pdf"))
  p1 <- tryCatch(dotplot(kegg.res, showCategory = 15, title = "GSEA, KEGG Enriched Pathways" , 
                split=".sign", font.size=8) + facet_grid(.~.sign),
                error = function(cond) return(NA))
  p2 <- tryCatch(dotplot(go.res, showCategory = 15, title = "GSEA, GO Enriched Pathways" , 
                split=".sign", font.size=8) + facet_grid(.~.sign),
                error = function(cond) return(NA))
  print(p1)
  print(p2)
  # running over-representation
  print("finished GSEA")
  markers <- FindMarkers(seu, test.use = 'MAST',
                       ident.1 = disease, ident.2 = "R", group.by = 'disease', subset.ident = ct,
                       min.pct = 0.4)
  sig.up <- row.names(markers)[(markers$p_val_adj < 0.1) & (markers$avg_log2FC > 0)]
  sig.up <- sig.up[!is.na(sig.up)]
  if(length(sig.up) > 10){
    write.csv(markers, 
              paste0("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/outs/DEG/",disease,"_",ct,"_DEGs.csv"))
    gene.df <- bitr(sig.up, fromType = "SYMBOL",
            toType = c("ENSEMBL"),
            OrgDb = org.Hs.eg.db)
    ego <- enrichGO(gene         = gene.df$ENSEMBL,
                     # universe      = names(geneList),
                    OrgDb         = org.Hs.eg.db,
                   keyType = 'ENSEMBL',
                    ont           = "BP",
                    pAdjustMethod = "BH",
                    pvalueCutoff  = 0.01,
                    qvalueCutoff  = 0.1,
            readable      = TRUE)
    p3 <- tryCatch(dotplot(ego, showCategory=15, font.size=8) + ggtitle("Over-representation, dotplot for GO:BP"),
                   error = function(cond) return(NA))
    p4 <- tryCatch(cnetplot(ego, foldChange=geneList[sig.up],
                   cex_label_category = 0.6, cex_label_gene = 0.3) + ggtitle("Over-representation, concept network for GO:BP"),
                   error = function(cond) return(NA))
    print(p3)
    print(p4)
  }
  dev.off()
}


```

```{r}
# ct_list <- unique(samples.combined$Man_anno)

cell_counts <- table(samples.combined@meta.data[samples.combined$disease=="KFD","Man_anno"])
cell_counts <- cell_counts + table(samples.combined@meta.data[samples.combined$disease=="R","Man_anno"])
ct_list <- names(cell_counts)[cell_counts > 50]
# ct_list <- ct_list[ct_list != 'Plasma cells']
# sapply(ct_list, function(x) ct_seu_diffex(samples.combined, ct = x, disease = 'KFD'))
# mclapply(ct_list, function(x) ct_seu_diffex(samples.combined, ct = x, disease = 'KFD'), mc.cores = 4)
future.apply::future_lapply(ct_list, function(x) ct_seu_diffex(samples.combined, ct = x, disease = 'KFD'), future.seed=TRUE)
```



## Preparing pseudobulk
```{r}
# set default assay to 'RNA'
DefaultAssay(object = dat_test) <- "SCT"
# DefaultAssay(object = dat_test) <- "combatBatch"

# Aggregate the counts per cell_type_preds and comp.ident

# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- dat_test@meta.data[, c("Man_anno", "comp.ident")]

# Aggregate across cluster-sample groups
pb <- aggregate.Matrix(t(GetAssayData(dat_test, slot='data')), 
                       groupings = groups, fun = "sum")

# get the cell type names
splitf <- sapply(stringr::str_split(rownames(pb), 
                                    pattern = "_",  
                                    n = 2), 
                 `[`, 1)
# split data frame by cell type, put sample/replicate names on
pb <- split.data.frame(pb, 
                       factor(splitf)) %>%
        lapply(function(u) 
                set_colnames(t(u), 
                             stringr::str_extract(rownames(u), "(?<=_).*")))
```


## Preparing for DESeq2
Since will likely only be comparing within cell type, metadata just needs to be replicate info.

As a test, I'll start with cDC1
```{r}
# generalized function
ct_diffex <- function(pb, ct, disease='KFD'){
  # browser()
  print(ct)
  ex <- pb[[which(names(pb)==ct)]]
  meta <- build_meta(ex)
  dds <- DESeqDataSetFromMatrix(data.frame(ex), 
                              colData = meta, 
                              design = ~ disease + tech)
  dds$disease <- relevel(dds$disease, ref = "R")
  keep <- rowSums(counts(dds)) >= 10
  dds <- dds[keep,]
  dds <- DESeq(dds)
  resLFC <- lfcShrink(dds, coef=paste0("disease_",disease,"_vs_R"), type="apeglm")
  resLFC <- resLFC[!is.na(resLFC$padj),]
  resLFC <- resLFC[order(resLFC$padj),]
  write.csv(resLFC[resLFC$padj < 0.1,], paste0("outs/sigDiffEx_",disease,"_",ct,".csv"))
  
  resLFC <- resLFC[order(resLFC$log2FoldChange, decreasing=T),]
  geneList <- resLFC$log2FoldChange
  sig.up <- geneList[resLFC$padj < 0.2 & resLFC$baseMean > 5]
  sig.up <- sig.up[!is.na(sig.up)]
  sig.up <- names(sig.up)[sig.up > 0]
  gene.df <- bitr(sig.up, fromType = "SYMBOL",
          toType = c("ENSEMBL"),
          OrgDb = org.Hs.eg.db)
  ego <- enrichGO(gene         = gene.df$ENSEMBL,
                   # universe      = names(geneList),
                  OrgDb         = org.Hs.eg.db,
                 keyType = 'ENSEMBL',
                  ont           = "BP",
                  pAdjustMethod = "BH",
                  pvalueCutoff  = 0.01,
                  qvalueCutoff  = 0.1,
          readable      = TRUE)
  
  pdf(paste0("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/outs/",disease,"_",ct,"_GO_enrichment.pdf"))
  plt1 <- dotplot(ego, showCategory=15) + ggtitle("dotplot for GO:BP")
  plt2 <- cnetplot(ego, foldChange=geneList[sig.up])
  print(plt1)
  print(plt2)
  dev.off()
}

```

Run the function outside of R markdown? I think there are conflicts with controlling the graphics device.
```{r}
# Run this outside the markdown
# test_ct <- c('Monocytes', 'Memory or effector T cells', 'Macrophages', 'Cytotoxic CD8 T cells', 
#              'Plasmacytoid dendritic cells', 'Naive B cells')
# lapply(test_ct, function(ct) ct_diffex(pb, ct))
```

trying limma...
The ComBat transformed values may work better in the there, since they've been log normalized...
```{r}
ex <- pb$Macrophages
# filter again??
drop_thresh <- quantile(rowMeans(ex), 0.25)
ex <- ex[rowMeans(ex) > drop_thresh,]

x.m <- rowMeans(ex)
x.v <- apply(ex,1,function(x) sqrt(sd(x)))
plot(log1p(x.m),x.v)

meta <- build_meta(ex)
d <- model.matrix(~disease, meta)
fit <- lmFit(ex, d)
fit <- eBayes(fit, trend=TRUE)
res <- topTable(fit, coef = 1)
res <- res[!is.na(res$adj.P.Val),]
res <- res[order(res$adj.P.Val),]
head(res)


```


```{r}
# make the metadata
ex <- pb$Macrophages
meta <- build_meta(ex)

# subset data to only include R and KFD
# meta <- meta[meta$disease %in% c('R','KFD'),]
# rownames(meta) <- meta$name
# ex <- ex[, colnames(ex) %in% meta$name]

# actually, I don't think I have to subset. I'll sort out the comparisons posthoc

dds <- DESeqDataSetFromMatrix(data.frame(ex), 
                              colData = meta, 
                              design = ~ disease + tech)

# set the reference
dds$disease <- relevel(dds$disease, ref = "R")

# drop low expression genes
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]

# normalize?

```

Running DESeq2
```{r}
dds <- DESeq(dds)
resultsNames(dds)
res <- results(dds, contrast = c("disease", "KFD", "R"), independentFiltering = T)
res <- res[order(res$padj), ]

resLFC <- lfcShrink(dds, coef="disease_KFD_vs_R", type="apeglm")
resLFC <- resLFC[order(resLFC$padj),]
summary(resLFC)

# visualize
plotCounts(dds, gene="IFI27", intgroup="disease")
```
## Calculating DEG with limma
```{r}
# make the metadata
ex <- pb$cDC1
meta <- build_meta(ex)

# input for limma
dge <- DGEList(counts=ex)
keep <- filterByExpr(dge)
dge <- dge[keep,,keep.lib.sizes=FALSE]
```




## Finally, GSEA
```{r}
resLFC <- markers[order(markers$avg_log2FC, decreasing = T),]
geneList <- resLFC$avg_log2FC; names(geneList) <- rownames(resLFC)
# convert gene symbols to entrez
newIDs <- mapIds(org.Hs.eg.db, keys = rownames(resLFC),
       column = "ENTREZID", keytype = "SYMBOL")
entrz.geneList <- geneList
names(entrz.geneList) <- newIDs
entrz.geneList <- entrz.geneList[!(is.na(names(entrz.geneList)))]
universe <- names(entrz.geneList)
# geneList <- geneList[!(is.na(geneList))]

# OVER-REPRESENTATION
# KEGG
sig.up <- entrz.geneList[newIDs[resLFC$padj < 0.2 & resLFC$baseMean > 5]]
sig.up <- sig.up[!is.na(sig.up)]
sig.up <- names(sig.up)[sig.up > 0]
kk <- enrichKEGG(gene         = sig.up,
                 organism     = 'hsa',
                 pvalueCutoff = 0.1,
                 universe = names(entrz.geneList)
                )
View(kk@result)

sig.up <- geneList[resLFC$p_val_adj < 0.1]
sig.up <- sig.up[!is.na(sig.up)]
sig.up <- names(sig.up)[sig.up > 0]
gene.df <- bitr(sig.up, fromType = "SYMBOL",
        toType = c("ENSEMBL"),
        OrgDb = org.Hs.eg.db)
ego <- enrichGO(gene         = gene.df$ENSEMBL,
                 # universe      = names(geneList),
                OrgDb         = org.Hs.eg.db,
               keyType = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.1,
        readable      = TRUE)
View(ego@result)

pdf("/mnt/isilon/cscb/Projects/10x/pillaiv/SCTC-VP-22/vinodh-5-3-integration/outs/KFD_Macrophage_GO_enrichment.pdf")
dotplot(ego, showCategory=15) + ggtitle("dotplot for GO:BP")

# ego <- pairwise_termsim(ego)
# emapplot(ego)

cnetplot(ego, foldChange=geneList[sig.up])
dev.off()
####
# GSEA
kegg.res <- gseKEGG(geneList     = entrz.geneList,
               organism     = 'hsa',
               minGSSize    = 20,
               pvalueCutoff = 0.5,
               verbose      = FALSE)

go.res <- gseGO(geneList     = geneList,
              OrgDb        = org.Hs.eg.db,
              ont          = "BP",
              minGSSize    = 50,
              maxGSSize    = 500,
              pvalueCutoff = 0.2,
              verbose      = FALSE)

# visualize
dotplot(kegg.res, showCategory = 10, title = "Enriched Pathways" , split=".sign") + facet_grid(.~.sign)
# gseaplot(kegg.res, geneSetID = "hsa04072", by = "runningScore", title = edo2$Description[1])
gseaplot(kegg.res, geneSetID = "hsa04072", by = "runningScore")
gseaplot(kegg.res, geneSetID = "hsa04658", by = "runningScore")

gseaplot(go.res, geneSetID = "GO:0032608", by = "runningScore")
```



